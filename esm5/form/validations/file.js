import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { getFileType, readAsArrayBuffer } from '../../file/read';
import { inArray } from '../../utils/array';
import { hasValue } from '../../utils/check';
export function maxFileSize(size) {
    return function (control) {
        var number = /[-]{0,1}[\d]*[.]{0,1}[\d]+/g;
        var sizeNumber = size.match(number);
        var multiplier = 1;
        switch (true) {
            case /[. 0-9]+(KB)/i.test(size):
                multiplier = 1e3;
                break;
            case /[. 0-9]+(MB)/i.test(size):
                multiplier = 1e6;
                break;
            case /[. 0-9]+(GB)/i.test(size):
                multiplier = 1e9;
                break;
        }
        if (hasValue(sizeNumber)) {
            var sizeOnBytes = parseFloat(sizeNumber.join('')) * multiplier;
            if (control.value) {
                if (control.value.size >= sizeOnBytes) {
                    return {
                        maxFileSize: true
                    };
                }
                return null;
            }
        }
        else {
            console.error('maxFileSize validation: Size must have a number');
        }
        return null;
    };
}
export function minFileSize(size) {
    return function (control) {
        var number = /[-]{0,1}[\d]*[.]{0,1}[\d]+/g;
        var sizeNumber = size.match(number);
        var multiplier = 1;
        switch (true) {
            case /[. 0-9]+(KB)/i.test(size):
                multiplier = 1e3;
                break;
            case /[. 0-9]+(MB)/i.test(size):
                multiplier = 1e6;
                break;
            case /[. 0-9]+(GB)/i.test(size):
                multiplier = 1e9;
                break;
        }
        if (hasValue(sizeNumber)) {
            var sizeOnBytes = parseFloat(sizeNumber.join('')) * multiplier;
            if (control.value) {
                if (control.value.size <= sizeOnBytes) {
                    return {
                        minFileSize: true
                    };
                }
                return null;
            }
        }
        else {
            console.error('minFileSize validation: Size must have a number');
        }
        return null;
    };
}
export function requiredFileType(ext) {
    return function (control) {
        var file = control.value;
        if (file) {
            if (!Array.isArray(ext)) {
                ext = [ext];
            }
            var types_1 = ext.map(function (type) { return type.toLowerCase(); });
            return readAsArrayBuffer(file)
                .pipe(map(function (result) {
                if (inArray(getFileType(result), types_1)) {
                    return null;
                }
                else {
                    return {
                        requiredFileType: true
                    };
                }
            }));
        }
        return of(null);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzZXJzb2wvbmd4LyIsInNvdXJjZXMiOlsiZm9ybS92YWxpZGF0aW9ucy9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDNUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTdDLE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBWTtJQUNwQyxPQUFPLFVBQUMsT0FBb0I7UUFFeEIsSUFBTSxNQUFNLEdBQUcsNkJBQTZCLENBQUM7UUFDN0MsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QyxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFFbkIsUUFBUSxJQUFJLEVBQUU7WUFDVixLQUFLLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMzQixVQUFVLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixNQUFNO1lBRVYsS0FBSyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDM0IsVUFBVSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsTUFBTTtZQUVWLEtBQUssZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLE1BQU07U0FDYjtRQUVELElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3RCLElBQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1lBRWpFLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRTtnQkFFZixJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLFdBQVcsRUFBRTtvQkFDbkMsT0FBTzt3QkFDSCxXQUFXLEVBQUUsSUFBSTtxQkFDcEIsQ0FBQztpQkFDTDtnQkFFRCxPQUFPLElBQUksQ0FBQzthQUNmO1NBQ0o7YUFBTTtZQUNILE9BQU8sQ0FBQyxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQztTQUNwRTtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUMsQ0FBQztBQUNOLENBQUM7QUFHRCxNQUFNLFVBQVUsV0FBVyxDQUFDLElBQVk7SUFDcEMsT0FBTyxVQUFDLE9BQW9CO1FBRXhCLElBQU0sTUFBTSxHQUFHLDZCQUE2QixDQUFDO1FBQzdDLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBRW5CLFFBQVEsSUFBSSxFQUFFO1lBQ1YsS0FBSyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDM0IsVUFBVSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsTUFBTTtZQUVWLEtBQUssZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLE1BQU07WUFFVixLQUFLLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMzQixVQUFVLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixNQUFNO1NBQ2I7UUFFRCxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN0QixJQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztZQUVqRSxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUU7Z0JBRWYsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxXQUFXLEVBQUU7b0JBQ25DLE9BQU87d0JBQ0gsV0FBVyxFQUFFLElBQUk7cUJBQ3BCLENBQUM7aUJBQ0w7Z0JBRUQsT0FBTyxJQUFJLENBQUM7YUFDZjtTQUNKO2FBQU07WUFDSCxPQUFPLENBQUMsS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7U0FDcEU7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEdBQXNCO0lBQ25ELE9BQU8sVUFBQyxPQUFvQjtRQUV4QixJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBRTNCLElBQUksSUFBSSxFQUFFO1lBRU4sSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3JCLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2Y7WUFFRCxJQUFNLE9BQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQUMsSUFBSSxJQUFLLE9BQUEsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFsQixDQUFrQixDQUFDLENBQUM7WUFFcEQsT0FBTyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7aUJBQ3pCLElBQUksQ0FDRCxHQUFHLENBQUMsVUFBQyxNQUFtQjtnQkFFcEIsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQUssQ0FBQyxFQUFFO29CQUNyQyxPQUFPLElBQUksQ0FBQztpQkFDZjtxQkFBTTtvQkFDSCxPQUFPO3dCQUNILGdCQUFnQixFQUFFLElBQUk7cUJBQ3pCLENBQUM7aUJBQ0w7WUFFTCxDQUFDLENBQUMsQ0FDTCxDQUFDO1NBQ1Q7UUFFRCxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDLENBQUM7QUFDTixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNWYWxpZGF0b3JGbiwgRm9ybUNvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGdldEZpbGVUeXBlLCByZWFkQXNBcnJheUJ1ZmZlciB9IGZyb20gJy4uLy4uL2ZpbGUvcmVhZCc7XHJcbmltcG9ydCB7IGluQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscy9hcnJheSc7XHJcbmltcG9ydCB7IGhhc1ZhbHVlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2snO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1heEZpbGVTaXplKHNpemU6IHN0cmluZyk6IFZhbGlkYXRvckZuIHtcclxuICAgIHJldHVybiAoY29udHJvbDogRm9ybUNvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IG51bWJlciA9IC9bLV17MCwxfVtcXGRdKlsuXXswLDF9W1xcZF0rL2c7XHJcbiAgICAgICAgY29uc3Qgc2l6ZU51bWJlciA9IHNpemUubWF0Y2gobnVtYmVyKTtcclxuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDE7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIC9bLiAwLTldKyhLQikvaS50ZXN0KHNpemUpOlxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IDFlMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAvWy4gMC05XSsoTUIpL2kudGVzdChzaXplKTpcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAxZTY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgL1suIDAtOV0rKEdCKS9pLnRlc3Qoc2l6ZSk6XHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gMWU5O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzVmFsdWUoc2l6ZU51bWJlcikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZU9uQnl0ZXMgPSBwYXJzZUZsb2F0KHNpemVOdW1iZXIuam9pbignJykpICogbXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250cm9sLnZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUuc2l6ZSA+PSBzaXplT25CeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ21heEZpbGVTaXplIHZhbGlkYXRpb246IFNpemUgbXVzdCBoYXZlIGEgbnVtYmVyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWluRmlsZVNpemUoc2l6ZTogc3RyaW5nKTogVmFsaWRhdG9yRm4ge1xyXG4gICAgcmV0dXJuIChjb250cm9sOiBGb3JtQ29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgbnVtYmVyID0gL1stXXswLDF9W1xcZF0qWy5dezAsMX1bXFxkXSsvZztcclxuICAgICAgICBjb25zdCBzaXplTnVtYmVyID0gc2l6ZS5tYXRjaChudW1iZXIpO1xyXG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgL1suIDAtOV0rKEtCKS9pLnRlc3Qoc2l6ZSk6XHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gMWUzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIC9bLiAwLTldKyhNQikvaS50ZXN0KHNpemUpOlxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IDFlNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAvWy4gMC05XSsoR0IpL2kudGVzdChzaXplKTpcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAxZTk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYXNWYWx1ZShzaXplTnVtYmVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaXplT25CeXRlcyA9IHBhcnNlRmxvYXQoc2l6ZU51bWJlci5qb2luKCcnKSkgKiBtdWx0aXBsaWVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5zaXplIDw9IHNpemVPbkJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRmlsZVNpemU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbWluRmlsZVNpemUgdmFsaWRhdGlvbjogU2l6ZSBtdXN0IGhhdmUgYSBudW1iZXInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVkRmlsZVR5cGUoZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSk6IEFzeW5jVmFsaWRhdG9yRm4ge1xyXG4gICAgcmV0dXJuIChjb250cm9sOiBGb3JtQ29udHJvbCk6IE9ic2VydmFibGU8VmFsaWRhdGlvbkVycm9ycyB8IG51bGw+ID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgZmlsZSA9IGNvbnRyb2wudmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChmaWxlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ID0gW2V4dF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gZXh0Lm1hcCgodHlwZSkgPT4gdHlwZS50b0xvd2VyQ2FzZSgpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWFkQXNBcnJheUJ1ZmZlcihmaWxlKVxyXG4gICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwKChyZXN1bHQ6IEFycmF5QnVmZmVyKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShnZXRGaWxlVHlwZShyZXN1bHQpLCB0eXBlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEZpbGVUeXBlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9mKG51bGwpO1xyXG4gICAgfTtcclxufVxyXG4iXX0=