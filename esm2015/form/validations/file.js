import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { getFileType, readAsArrayBuffer } from '../../file/read';
import { inArray } from '../../utils/array';
import { hasValue } from '../../utils/check';
export function maxFileSize(size) {
    return (control) => {
        const number = /[-]{0,1}[\d]*[.]{0,1}[\d]+/g;
        const sizeNumber = size.match(number);
        let multiplier = 1;
        switch (true) {
            case /[. 0-9]+(KB)/i.test(size):
                multiplier = 1e3;
                break;
            case /[. 0-9]+(MB)/i.test(size):
                multiplier = 1e6;
                break;
            case /[. 0-9]+(GB)/i.test(size):
                multiplier = 1e9;
                break;
        }
        if (hasValue(sizeNumber)) {
            const sizeOnBytes = parseFloat(sizeNumber.join('')) * multiplier;
            if (control.value) {
                if (control.value.size >= sizeOnBytes) {
                    return {
                        maxFileSize: true
                    };
                }
                return null;
            }
        }
        else {
            console.error('maxFileSize validation: Size must have a number');
        }
        return null;
    };
}
export function minFileSize(size) {
    return (control) => {
        const number = /[-]{0,1}[\d]*[.]{0,1}[\d]+/g;
        const sizeNumber = size.match(number);
        let multiplier = 1;
        switch (true) {
            case /[. 0-9]+(KB)/i.test(size):
                multiplier = 1e3;
                break;
            case /[. 0-9]+(MB)/i.test(size):
                multiplier = 1e6;
                break;
            case /[. 0-9]+(GB)/i.test(size):
                multiplier = 1e9;
                break;
        }
        if (hasValue(sizeNumber)) {
            const sizeOnBytes = parseFloat(sizeNumber.join('')) * multiplier;
            if (control.value) {
                if (control.value.size <= sizeOnBytes) {
                    return {
                        minFileSize: true
                    };
                }
                return null;
            }
        }
        else {
            console.error('minFileSize validation: Size must have a number');
        }
        return null;
    };
}
export function requiredFileType(ext) {
    return (control) => {
        const file = control.value;
        if (file) {
            if (!Array.isArray(ext)) {
                ext = [ext];
            }
            const types = ext.map((type) => type.toLowerCase());
            return readAsArrayBuffer(file)
                .pipe(map((result) => {
                if (inArray(getFileType(result), types)) {
                    return null;
                }
                else {
                    return {
                        requiredFileType: true
                    };
                }
            }));
        }
        return of(null);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzZXJzb2wvbmd4LyIsInNvdXJjZXMiOlsiZm9ybS92YWxpZGF0aW9ucy9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDNUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTdDLE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBWTtJQUNwQyxPQUFPLENBQUMsT0FBb0IsRUFBMkIsRUFBRTtRQUVyRCxNQUFNLE1BQU0sR0FBRyw2QkFBNkIsQ0FBQztRQUM3QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQztRQUVuQixRQUFRLElBQUksRUFBRTtZQUNWLEtBQUssZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLE1BQU07WUFFVixLQUFLLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMzQixVQUFVLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixNQUFNO1lBRVYsS0FBSyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDM0IsVUFBVSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsTUFBTTtTQUNiO1FBRUQsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdEIsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7WUFFakUsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO2dCQUVmLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksV0FBVyxFQUFFO29CQUNuQyxPQUFPO3dCQUNILFdBQVcsRUFBRSxJQUFJO3FCQUNwQixDQUFDO2lCQUNMO2dCQUVELE9BQU8sSUFBSSxDQUFDO2FBQ2Y7U0FDSjthQUFNO1lBQ0gsT0FBTyxDQUFDLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1NBQ3BFO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUdELE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBWTtJQUNwQyxPQUFPLENBQUMsT0FBb0IsRUFBMkIsRUFBRTtRQUVyRCxNQUFNLE1BQU0sR0FBRyw2QkFBNkIsQ0FBQztRQUM3QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQztRQUVuQixRQUFRLElBQUksRUFBRTtZQUNWLEtBQUssZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLFVBQVUsR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLE1BQU07WUFFVixLQUFLLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUMzQixVQUFVLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixNQUFNO1lBRVYsS0FBSyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDM0IsVUFBVSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsTUFBTTtTQUNiO1FBRUQsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdEIsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7WUFFakUsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO2dCQUVmLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksV0FBVyxFQUFFO29CQUNuQyxPQUFPO3dCQUNILFdBQVcsRUFBRSxJQUFJO3FCQUNwQixDQUFDO2lCQUNMO2dCQUVELE9BQU8sSUFBSSxDQUFDO2FBQ2Y7U0FDSjthQUFNO1lBQ0gsT0FBTyxDQUFDLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1NBQ3BFO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxHQUFzQjtJQUNuRCxPQUFPLENBQUMsT0FBb0IsRUFBdUMsRUFBRTtRQUVqRSxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBRTNCLElBQUksSUFBSSxFQUFFO1lBRU4sSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3JCLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2Y7WUFFRCxNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUVwRCxPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQztpQkFDekIsSUFBSSxDQUNELEdBQUcsQ0FBQyxDQUFDLE1BQW1CLEVBQUUsRUFBRTtnQkFFeEIsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFO29CQUNyQyxPQUFPLElBQUksQ0FBQztpQkFDZjtxQkFBTTtvQkFDSCxPQUFPO3dCQUNILGdCQUFnQixFQUFFLElBQUk7cUJBQ3pCLENBQUM7aUJBQ0w7WUFFTCxDQUFDLENBQUMsQ0FDTCxDQUFDO1NBQ1Q7UUFFRCxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDLENBQUM7QUFDTixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNWYWxpZGF0b3JGbiwgRm9ybUNvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGdldEZpbGVUeXBlLCByZWFkQXNBcnJheUJ1ZmZlciB9IGZyb20gJy4uLy4uL2ZpbGUvcmVhZCc7XHJcbmltcG9ydCB7IGluQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscy9hcnJheSc7XHJcbmltcG9ydCB7IGhhc1ZhbHVlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2snO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1heEZpbGVTaXplKHNpemU6IHN0cmluZyk6IFZhbGlkYXRvckZuIHtcclxuICAgIHJldHVybiAoY29udHJvbDogRm9ybUNvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IG51bWJlciA9IC9bLV17MCwxfVtcXGRdKlsuXXswLDF9W1xcZF0rL2c7XHJcbiAgICAgICAgY29uc3Qgc2l6ZU51bWJlciA9IHNpemUubWF0Y2gobnVtYmVyKTtcclxuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDE7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIC9bLiAwLTldKyhLQikvaS50ZXN0KHNpemUpOlxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IDFlMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAvWy4gMC05XSsoTUIpL2kudGVzdChzaXplKTpcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAxZTY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgL1suIDAtOV0rKEdCKS9pLnRlc3Qoc2l6ZSk6XHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gMWU5O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzVmFsdWUoc2l6ZU51bWJlcikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZU9uQnl0ZXMgPSBwYXJzZUZsb2F0KHNpemVOdW1iZXIuam9pbignJykpICogbXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250cm9sLnZhbHVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUuc2l6ZSA+PSBzaXplT25CeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ21heEZpbGVTaXplIHZhbGlkYXRpb246IFNpemUgbXVzdCBoYXZlIGEgbnVtYmVyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWluRmlsZVNpemUoc2l6ZTogc3RyaW5nKTogVmFsaWRhdG9yRm4ge1xyXG4gICAgcmV0dXJuIChjb250cm9sOiBGb3JtQ29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgbnVtYmVyID0gL1stXXswLDF9W1xcZF0qWy5dezAsMX1bXFxkXSsvZztcclxuICAgICAgICBjb25zdCBzaXplTnVtYmVyID0gc2l6ZS5tYXRjaChudW1iZXIpO1xyXG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMTtcclxuXHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgL1suIDAtOV0rKEtCKS9pLnRlc3Qoc2l6ZSk6XHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gMWUzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIC9bLiAwLTldKyhNQikvaS50ZXN0KHNpemUpOlxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IDFlNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAvWy4gMC05XSsoR0IpL2kudGVzdChzaXplKTpcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSAxZTk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChoYXNWYWx1ZShzaXplTnVtYmVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaXplT25CeXRlcyA9IHBhcnNlRmxvYXQoc2l6ZU51bWJlci5qb2luKCcnKSkgKiBtdWx0aXBsaWVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5zaXplIDw9IHNpemVPbkJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRmlsZVNpemU6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbWluRmlsZVNpemUgdmFsaWRhdGlvbjogU2l6ZSBtdXN0IGhhdmUgYSBudW1iZXInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVkRmlsZVR5cGUoZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSk6IEFzeW5jVmFsaWRhdG9yRm4ge1xyXG4gICAgcmV0dXJuIChjb250cm9sOiBGb3JtQ29udHJvbCk6IE9ic2VydmFibGU8VmFsaWRhdGlvbkVycm9ycyB8IG51bGw+ID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgZmlsZSA9IGNvbnRyb2wudmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChmaWxlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgZXh0ID0gW2V4dF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gZXh0Lm1hcCgodHlwZSkgPT4gdHlwZS50b0xvd2VyQ2FzZSgpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWFkQXNBcnJheUJ1ZmZlcihmaWxlKVxyXG4gICAgICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwKChyZXN1bHQ6IEFycmF5QnVmZmVyKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShnZXRGaWxlVHlwZShyZXN1bHQpLCB0eXBlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEZpbGVUeXBlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9mKG51bGwpO1xyXG4gICAgfTtcclxufVxyXG4iXX0=